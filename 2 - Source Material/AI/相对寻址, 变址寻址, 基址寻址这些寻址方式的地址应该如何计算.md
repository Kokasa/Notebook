相对寻址、变址寻址和基址寻址都属于偏移寻址方式，它们通过将指令中给出的偏移量与某个寄存器中的值相加来计算操作数的有效地址。这三种寻址方式在概念上比较相似，但应用场景略有不同。下面我将分别详细讲解它们的地址计算方式。

**1. 相对寻址（Relative Addressing）**

- **计算公式：** 有效地址（EA）= 程序计数器（PC）的当前值 + 指令中的偏移量（也称为相对地址或位移量）
    
- **作用：** 主要用于转移指令（如跳转指令），方便程序在内存中相对位置的移动。
    
- **特点：**
    
    - 偏移量通常是带符号的整数，可以是正数（向前跳转）或负数（向后跳转）。
    - 寻址范围相对较小，受偏移量位数的限制。
    - 有利于编写可重定位程序，因为指令中的地址是相对于当前指令的偏移量，而不是绝对地址。
- **举例：** 假设当前 PC 的值为 2000，一条相对跳转指令的偏移量为 +10，则跳转的目标地址为 2000 + 10 = 2010。如果偏移量为 -5，则跳转的目标地址为 2000 - 5 = 1995。
    

**2. 变址寻址（Indexed Addressing）**

- **计算公式：** 有效地址（EA）= 变址寄存器（IX 或 IR）的内容 + 指令中的偏移量（也称为基地址或位移量）
    
- **作用：** 主要用于处理数组或字符串等数据结构，方便访问数组中的元素。
    
- **特点：**
    
    - 变址寄存器通常用于存放数组或字符串的首地址。
    - 偏移量用于指定数组元素的下标。
    - 可以方便地实现数组的遍历。
- **举例：** 假设变址寄存器 IX 的值为 1000（数组的首地址），一条变址寻址指令的偏移量为 5，则操作数的地址为 1000 + 5 = 1005，即数组的第 6 个元素（假设数组元素的大小为一个存储单元）。
    

**3. 基址寻址（Base Addressing）**

- **计算公式：** 有效地址（EA）= 基址寄存器（BR 或 B）的内容 + 指令中的偏移量（也称为位移量）
    
- **作用：** 主要用于程序的重定位和分配内存空间。
    
- **特点：**
    
    - 基址寄存器通常用于存放程序在内存中的起始地址（基地址）。
    - 偏移量用于指定程序内部的相对地址。
    - 当程序在内存中移动时，只需要修改基址寄存器的内容，而不需要修改程序中的指令。
- **举例：** 假设基址寄存器 BR 的值为 5000（程序在内存中的起始地址），一条基址寻址指令的偏移量为 100，则操作数的地址为 5000 + 100 = 5100，即程序内部偏移为 100 的存储单元。
    

**对比和总结**

|寻址方式|计算公式|主要用途|特点|
|---|---|---|---|
|相对寻址|EA = PC + 偏移量|转移指令|偏移量带符号，寻址范围小，利于程序重定位|
|变址寻址|EA = IX + 偏移量|数组/字符串处理|IX 存放数组首地址，偏移量为下标，方便数组遍历|
|基址寻址|EA = BR + 偏移量|程序重定位/内存分配|BR 存放程序起始地址，偏移量为程序内部相对地址，方便程序在内存中的移动|

**关键区别：**

- **使用的寄存器不同：** 相对寻址使用 PC，变址寻址使用变址寄存器 IX，基址寻址使用基址寄存器 BR。
- **用途不同：** 虽然计算公式类似，但它们的主要用途不同，决定了它们在程序设计和内存管理中的应用场景。
- **偏移量的含义不同：** 在相对寻址中，偏移量是相对于 PC 的偏移；在变址寻址中，偏移量是相对于数组首地址的偏移；在基址寻址中，偏移量是相对于程序起始地址的偏移。

理解这三种寻址方式的关键在于理解它们各自使用的寄存器及其含义，以及偏移量在不同寻址方式中的不同解释。掌握这些概念有助于深入理解计算机的指令系统和内存管理机制。