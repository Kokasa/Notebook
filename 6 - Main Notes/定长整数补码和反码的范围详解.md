2024-12-15    15:48

status: #adult 
tags: 


# [[补码]]和反码的范围详解

## 澄清补码和反码的结构与概念

在机器数长度n下, 
1. **首位为符号位**, 用来记录正负, 0正1负
2. 数值部分长 **n-1**


## 补码范围推导
假设你已经熟悉[[模(mod)]]的概念

补码能够通过 **加减模长** 来控制显示范围不超过机器数


### 对正数
正数补码与原码相同, 范围是 $0<[X]_{补}\leq2^{n-1}-1$
表现为二进制(假定n长为5): $$00000<[X]_{补}\leq01111$$
### 对负数
负数补码符号位为1, 
范围是 $-\frac{模长}{2}\leq补码<-1$

假定机器数长度为5, 模长为$2^{5}$

表现为二进制: $$10000\leq补码<-1$$
- 我应该如何理解补码?
	- 补码的一切都和模长有关, 都在机器数的位数限制之下, 通过首位的改变将机器数划分成两个相等部分
	- 补码所表示的负数较反码多一位, 所以不能使用反码相关的二级结论
	- 可以尝试一下用现有补码加减模长, 或者拿模长减去补码, 可以发现**补码的最小值10000与最大值01111互补**, 这有关于补码的对称性, 属于推导出补码的现象
## 反码范围推导

正数不变, 负数按位取反

注意反码有**正负零**之分
所以在存储0上浪费一个编码位

表现为**最大值和最小值的绝对值相同**








# References
[[为什么同一个机器数表示补码时范围比反码大]]
[[模运算(mod)的性质]]
[[补码的最大值和最小值为什么互补]]