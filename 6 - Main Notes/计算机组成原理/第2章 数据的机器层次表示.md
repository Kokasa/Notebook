status: #adult

tags: 

### 数值数据的表示
	数据有无符号数和有符号数之分
	根据编码不同又分为原码, 反码, 补码

#### 计算机中的数值数据
**十进制数(Decimal)**: 与人类的手指数量密不可分, 源自拉丁语中的"十" decimus
**二进制数(Binary)**: "bi-"前缀表示2, "-ary"表示性质, 即二元性
**十六进制数(Hexadecimal)**: "Hexa"源自希腊语的六, 但这里组合表示为十六, 为**2的四次方**
**八进制数(Octal)**: "oct-" 为拉丁语中的八, "-al" 表示属于某一类, 即基于八的系统, 为**2的三次方**

#### 无符号数和有符号数
##### 无符号数
整个机器字长的所有位都用来表示数值, 不记录符号
事实上在人类历史上符号的概念出现的相当晚, 大约公元二世纪, 负数出现在人们的论述中, 而直到十七世纪, 我们现在使用的[[负数的起源]]才被真正意义上被用在运算之中
一般计算机中会有一些无符号数的运算和处理

例如: $$ N_{1} = 01001B = 0x11 = 9D = 9H $$
$$ N_{2} = 11001B = 0x31 = 25D = 19H $$
##### 真值
我们生活中使用的有符号数, 即通过正负号和绝对值来表示数值大小
通过这种形式表示的数值被称为**真值**

##### 机器数
计算机识别符号十分困难, 为此需要将符号数字化, 约定:
**二进制的最高位是符号位: 0正  1负**

在计算机中这种表示形式为**机器数**, 有原码, 反码, 补码三种不同的表现形式

原码: $$[X]_{原}$$
反码: $$[X]_{反}$$
补码:  $$[X]_{补}$$

#### 原码
	最简单的机器数表示
最高位为符号位, 0正 1负, 数值部分与真值相同

小数的原码表示: 
$$
[X]_{原} = \begin{cases}
X,  &0 \leq X <1
\\ \\
1-X=1+|X|, &-1<X \leq 0

\end{cases}$$
小于零情况解释: 这样做是为了将首位变成1, 所以需要将X取绝对值并加1(取值范围的最大值)


$$ X = 0.0110 \quad\quad [X]_{原} = 0.0110$$


负数小数的原码表示: $$ X = -0.0110 \quad\quad [X]_{原} = 1.0110$$
纯整数更容易理解, 最高位表示符号即可(机器数长4位): $$X = -0 \quad\quad [X]_{原} = 1000$$
##### 优点

- 直观易懂, 机器数和真值之间转换容易

- 实现乘除简单
##### 缺点

实现加减运算较为复杂


#### 补码
##### 模(Module)
	起源于线性代数, 标量域为环(ring)而非域(field)
**注意** ,模长为可表示的数的范围, 而非能表示的最大的数
使用钟表更易于理解:

钟表一周能够表示的最大小时数为 12
所以表示4点, 16点, 时针指向相同的位置, 称为**同余**
钟表的一周长度 12 称之为**模(module)**

就像中学中 $$ 10^\circ = 370^\circ \quad (模长360^\circ)$$

类推: 
-2 与 10 对 模12 互补
-2 的 补数 为 10 (模长12)

确定模, 就能找到与负数等价的正数


因为计算机中 机器数长为固定值, 正适合作为模长, 进行补码运算:
$$
[X]_{补} = \begin{cases} 
X , &0 \leq X < \frac{M}{2}  \\ \\
M+X , &-\frac{M}{2} \leq X < 0
\end{cases} (\bmod M) $$
再次强调模是可表示的数的数量, 而非最大值
##### 补码表示
这里仅给出补码的表示和运算规则, 关于原理
详见书籍《[[编码 隐匿在计算机软硬件背后的语言]]》, wiki: [维基百科: 二补数](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8)

**正数: 补码表示形式和真值相同**
**负数: 将真值部分按位取反, 最低位加1**

对补码运算的解释: 
$$\begin{array}{r}
10.0000 \\
- 0.0110 \\
\hline 
1.1010
\end{array} 
= 
\begin{array}{r}
1.1111\\
+0.0001\\
-0.0110 \\
\hline
1.1010
\end{array}
$$
解释: 这样运算时就将减法处理为**按位非运算**, 然后在最后位补1
###### 实际中补码的运算
正数: $$[X]_{补} = [X]_{原}=X$$
负数: 
 1. 符号位不变
 2. 自低向高数, 第一个1以及右部的0保持不变, 其余位取反

##### 反码表示
正数: 表示相同
负数: 按位取反

#### 三种机器数的比较与转换

 - 补码和反码的符号位也属于数值的一部分, 参与运算
 - 原码的符号位不参与运算
 - 补码的负数范围较正数范围更宽, 能多表示一个负数

### 机器数的定点表示和浮点表示
	根据小数点位置是否固定区分为定点表示和浮点表示
#### 定点表示
##### 定点小数
	即纯小数: 绝对值小于1的小数
只表示小于1的小数, 不需要记录整数位
小数点位置固定, 不需要记录在机器数中
由符号位(数符)和数值位组成

##### 定点整数
	即纯整数: 无小数位
由数值位(数符)和数值位组成

##### 溢出
参与定点数运算的数以及结果都必须保证在该定点数能表示的范围内
否则称为"**溢出**"

#### 浮点表示法
	对于既有整数又有小数的混合数, 小数点的位置通常不是固定的
	为此需要让小数点的位置根据需要浮动

[[浮点数(Floating Point)]]

##### 浮点数阶码的移码表示法

结论: 在[[移码(Offset Binary)]]中
- 最高位0为正, 1为负
- 移码全为零时真值最小, 全为1时真值最大, 较为直观
- 0在移码中表示形式唯一, 即最高位为1, 其他位为0
- 可以将移码视为无符号数, 直接按照无符号数规则比较大小
- 同一数值的移码和补码除了最高位相反之外, 其他位相同
##### 为什么用移码表示浮点数的阶码
- 便于比较浮点数大小
- 简化机器中的判零:
	- 阶码全为0, 尾数也为0时表示机器零

# Relevance

[[模运算(mod)]]
[[为什么使用反码+1计算补码]]

