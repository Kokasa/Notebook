2024-12-14    12:34

status: #adult
tags: [[Computer Science]], [[Math]], [[机器数]]


# 浮点数

```
对于计算机中的浮点数, 我们采用的存储思想是使用一部分数值表示小数点的位置, 看起来就像小数点会"浮动"一样

所以可以简单将浮点数格式看做 |阶符|阶码|位符|尾数|

在表示数值时, 首先确定隐含的基数r, 将阶码作为E, 尾数作为M

$$数值=r^E\timesM$$

但是要注意的是尾数部分存放的是纯小数, 在使用时实际上为"0.M"的形式

接下来也可以简单看一下浮点数的最大最小值

当阶码最大, 尾数为最大正数时, 浮点数为最大值

当阶码最小, 尾数为最小正数时, 浮点数为最小正数(也是浮点数能表示的最小精度)

当阶码最大, 尾数为最小负数时, 浮点数最小

当阶码最小, 尾数为最大负数时, 浮点数为最小负数

常用的标准(如IEEE标准中)尾数一般只用原码表示, 这意味着尾数的大小十分直观, 最大时为全1, 即0.11111... , 最小则只有最后一位是1
```
## 什么是浮点数

让小数点根据需要进行浮动, 就是浮点数

## 浮点数的组成

- 表示有效数字精度的 **尾数**
	- 纯小数
	- 由[[原码]]或者[[补码]]表示
- 控制表示范围的 **阶码**
	- 纯整数
	- 用[[移码(Offset Binary)]]或者[[补码]]表示

## 规格化浮点数

为了充分利用尾数的有效数位, 规定尾数的最高位数一定是一个有效值(即不能为0)

例如:  0.0001101 可以表示为 $0.1101\times2^{-11}$

### 原码表示

尾数用原码表示时, 规格化浮点数的位数的最高数位 总是为 **1**
### 补码表示

在尾数用补码表示时, 规格化浮点数满足尾数最高数位与符号位不同

### 规格化操作

通过调整一个非规格化浮点数的尾数和阶码的大小, **使非零的浮点数在尾数的最高位上保持一个有效值**

## 浮点数的溢出

![[浮点数_Floating Point_-1740059377790.jpeg]]

## 机器零

只要尾数为0, 不论阶码为何值都作为机器0处理
### 机器零的标准格式
尾数为0, 阶码为最小值

# References
