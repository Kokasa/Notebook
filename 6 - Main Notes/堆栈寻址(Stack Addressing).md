2025-02-17    11:28

status: #adult 
tags: [[寻址方式]]


# 堆栈寻址(Stack Addressing)

```
堆栈寻址我认为比较好理解, 将待执行的指令一条条压入栈中, 遵循栈严格的LIFO, 在执行的时候一条一条从栈顶弹出就可以了, 当然, 在具体实现时不能用手拿出来, 而是要通过堆栈指针SP
```

```
我刚刚学习了堆栈寻址操作, 发现当有数据入栈时, 需要先移动SP到栈顶, 有数据出栈时, 先弹出数据再移动SP, 数据出入栈是否是通过SP进行的?
```
## 核心思想

- LIFO: 这种数据结构本身就有严格的读取顺序, 不需要额外分配内存来标识
- [[堆栈指针(Stack Pointer, SP)]]: 这是一个特殊的寄存器, 指示栈顶
- push
- pop

## 堆栈寻址流程

1. 初始化: 令SP指向堆栈的起始地址
2. 压栈操作: SP值先加一个单位, 然后将目标指令放在SP指向的地址
3. 弹栈操作: 将SP指向的数据取出, 然后减小SP的值

```
我想了一种形象的比喻, 假设SP是一条线, 我要在这条线上串珠子, 我需要先解开线首端的结, 然后把珠子传进来, 再打上结
我们只需要关注珠子的串入和拿出即可, 不需要刻意关注珠子的状态和位置, 因为他们在线上自己就是一串
```

## 应用场景


```
堆栈操作十分适合于"恢复现场"
```

- 函数调用
	函数要保存当前的执行状态才能跳转到子函数执行, 当子函数执行完返回时再将执行过程一条一条弹出来, 恢复到函数调用之前的状态
- 中断处理
	将程序状态字和返回地址等压入栈, 以便在中断处理完成后返回到原来的程序执行位置
- 临时数据存储
	比如计算表达式时将中间结果压入堆栈供后续使用


# References

[[用堆栈操作来'恢复现场']]

[[堆栈寻址的操作顺序-使用SP]]