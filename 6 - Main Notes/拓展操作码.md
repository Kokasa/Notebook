2025-01-04    18:20

status: #adult 

# 拓展操作码

## 指定CPU具体操作的操作码

操作码决定机器指令的具体操作, 它的长度会直接影响到指令集的丰富程度以及编码的方式

给机器指令指定合适的操作码长度是编排计算机指令集很重要的部分

## 操作码长度对机器指令的影响

1. 指令数量的限制
	- 假如操作码长度固定为n位, 最多只能表述$2^{n}$种操作, 如果机器指令需要更多的操作就要增加操作码的长度
	- 这个问题能通过变长操作码位数来解决, 称作拓展操作码操作
2. 地址码位数的限制
	- 如果指令字长固定, 盲目增长操作码长度会挤占地址码位数, 限制指令的寻址范围
3. 编码效率的限制
	- 固定长度的操作码会造成一定空间上的浪费, 如果某个功能只需要10条指令, 但操作码长度为4位, 就会有6个编码空闲
	- 可变长度的操作码能更有效的利用编码空间, 在需要较少指令的时候使用较短的操作码

## 计算机是如何进行拓展操作码的

在指令字长受限的情况下, 通过牺牲地址码的位数来换取更多的操作码, 来增加指令集中指令的数量
属于是有目的的"拆东墙补西墙"

比如说我们有16位指令字长, 如果要在这个指令字长中包含 三地址指令, 二地址指令, 一地址指令, 零地址指令

- 我们可以先划分好三地址指令, 假如它的操作码长度为4位, 剩下的12位平均分配给三个地址码

```
| 基本操作码 (4位) | 地址1 (4位) | 地址2 (4位) | 地址3 (4位) |
```

- 上面划分三地址指令时, 我们默认引入了4位长度的操作码, 作为基本操作码, 基本操作码会有一些特殊的值, 用来向计算机呼喊: "接下来就不是三地址指令啦! 接下来是其他的指令!"
- 假定这个特殊的基本操作码值为1111, cpu在读到这里的指令时就知道这是一步需要解码的拓展指令, 接下来就需要把剩下的12位 其中的4位 用作拓展操作码, 剩下的位数分配给两个地址码, 成为二地址指令
```
| 基本操作码 (1111) | 扩展操作码 (4位) | 地址1 (4位) | 地址2 (4位) |
```

- 同样的, 我们可以完成一地址指令和零地址指令的划分
```
| 基本操作码 (1111) | 扩展操作码1 (1111) | 扩展操作码2 (4位) | 地址1 (4位) |
```

```
| 基本操作码 (1111) | 扩展操作码1 (1111) | 扩展操作码2 (1111) | 扩展操作码3 (4位) |
```

# References

[[机器指令中的操作码, 以及操作码长度不固定时需要做什么]]

[[有趣的拓展操作码]]

[[拓展操作码是如何实现的]]
